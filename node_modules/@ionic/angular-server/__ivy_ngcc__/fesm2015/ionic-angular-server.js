import { __decorate } from 'tslib';
import { DOCUMENT } from '@angular/common';
import { NgModule, APP_ID } from '@angular/core';
import { BEFORE_APP_SERIALIZED } from '@angular/platform-server';
import { hydrateDocument } from '@ionic/core/hydrate';

// @dynamic
import * as ɵngcc0 from '@angular/core';
let IonicServerModule = class IonicServerModule {
};
IonicServerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IonicServerModule });
IonicServerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IonicServerModule_Factory(t) { return new (t || IonicServerModule)(); }, providers: [
        {
            provide: BEFORE_APP_SERIALIZED,
            useFactory: hydrateIonicComponents,
            multi: true,
            deps: [DOCUMENT, APP_ID]
        }
    ] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonicServerModule, [{
        type: NgModule,
        args: [{
                providers: [
                    {
                        provide: BEFORE_APP_SERIALIZED,
                        useFactory: hydrateIonicComponents,
                        multi: true,
                        deps: [DOCUMENT, APP_ID]
                    }
                ]
            }]
    }], null, null); })();
// @dynamic
// tslint:disable-next-line: only-arrow-functions
function hydrateIonicComponents(doc, appId) {
    return () => {
        return hydrateDocument(doc, {
            clientHydrateAnnotations: false,
            excludeComponents: [
                // overlays
                'ion-action-sheet',
                'ion-alert',
                'ion-loading',
                'ion-modal',
                'ion-picker',
                'ion-popover',
                'ion-toast',
                'ion-toast',
                // navigation
                'ion-router',
                'ion-route',
                'ion-route-redirect',
                'ion-router-link',
                'ion-router-outlet',
                // tabs
                'ion-tabs',
                'ion-tab',
                // auxiliar
                'ion-picker-column',
                'ion-virtual-scroll'
            ]
        })
            .then(hydrateResults => {
            hydrateResults.diagnostics.forEach(d => {
                if (d.type === 'error') {
                    console.error(d.messageText);
                }
                else if (d.type === 'debug') {
                    console.debug(d.messageText);
                }
                else {
                    console.log(d.messageText);
                }
            });
            if (doc.head != null) {
                const styleElms = doc.head.querySelectorAll('style[data-styles]');
                for (let i = 0; i < styleElms.length; i++) {
                    styleElms[i].setAttribute('ng-transition', appId);
                }
            }
            if (doc.body != null) {
                const ionPages = doc.body.querySelectorAll('.ion-page.ion-page-invisible');
                for (let i = 0; i < ionPages.length; i++) {
                    ionPages[i].classList.remove('ion-page-invisible');
                }
            }
        });
    };
}

/**
 * Generated bundle index. Do not edit.
 */

export { IonicServerModule, hydrateIonicComponents as ɵa };

//# sourceMappingURL=ionic-angular-server.js.map