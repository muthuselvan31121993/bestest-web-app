import { __decorate } from 'tslib';
import { DOCUMENT } from '@angular/common';
import { NgModule, APP_ID } from '@angular/core';
import { BEFORE_APP_SERIALIZED } from '@angular/platform-server';
import { hydrateDocument } from '@ionic/core/hydrate';

// @dynamic
var IonicServerModule = /** @class */ (function () {
    function IonicServerModule() {
    }
    IonicServerModule = __decorate([
        NgModule({
            providers: [
                {
                    provide: BEFORE_APP_SERIALIZED,
                    useFactory: hydrateIonicComponents,
                    multi: true,
                    deps: [DOCUMENT, APP_ID]
                }
            ]
        })
    ], IonicServerModule);
    return IonicServerModule;
}());
// @dynamic
// tslint:disable-next-line: only-arrow-functions
function hydrateIonicComponents(doc, appId) {
    return function () {
        return hydrateDocument(doc, {
            clientHydrateAnnotations: false,
            excludeComponents: [
                // overlays
                'ion-action-sheet',
                'ion-alert',
                'ion-loading',
                'ion-modal',
                'ion-picker',
                'ion-popover',
                'ion-toast',
                'ion-toast',
                // navigation
                'ion-router',
                'ion-route',
                'ion-route-redirect',
                'ion-router-link',
                'ion-router-outlet',
                // tabs
                'ion-tabs',
                'ion-tab',
                // auxiliar
                'ion-picker-column',
                'ion-virtual-scroll'
            ]
        })
            .then(function (hydrateResults) {
            hydrateResults.diagnostics.forEach(function (d) {
                if (d.type === 'error') {
                    console.error(d.messageText);
                }
                else if (d.type === 'debug') {
                    console.debug(d.messageText);
                }
                else {
                    console.log(d.messageText);
                }
            });
            if (doc.head != null) {
                var styleElms = doc.head.querySelectorAll('style[data-styles]');
                for (var i = 0; i < styleElms.length; i++) {
                    styleElms[i].setAttribute('ng-transition', appId);
                }
            }
            if (doc.body != null) {
                var ionPages = doc.body.querySelectorAll('.ion-page.ion-page-invisible');
                for (var i = 0; i < ionPages.length; i++) {
                    ionPages[i].classList.remove('ion-page-invisible');
                }
            }
        });
    };
}

/**
 * Generated bundle index. Do not edit.
 */

export { IonicServerModule, hydrateIonicComponents as Éµa };
//# sourceMappingURL=ionic-angular-server.js.map
